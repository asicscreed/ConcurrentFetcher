{"version":3,"file":"concurrentfetcher.umd.js","sources":["concurrentfetcher.js"],"sourcesContent":["/**\n * FetchError class to encapsulate fetch errors.\n */\nexport class FetchError extends Error {\n    /**\n     * @param {string} message - The Fetch request error message\n     * @param {string | Request} url - The url request that failed\n     * @param {number} status - The http error status\n     */\n    constructor(message, url, status) {\n        super(message);\n        //this.name = this.constructor.name; minified...\n        this.name = 'FetchError';\n        this.url = url;\n        this.status = status;\n    }\n}\n/**\n * JsonParseError class to encapsulate JSON parse errors.\n */\nexport class JsonParseError extends SyntaxError {\n    /**\n     * @param {string} message - The JSON parse error message\n     * @param {string | Request} url - The url request that failed\n     */\n    constructor(message, url) {\n        super(message);\n        //this.name = this.constructor.name; minified...\n        this.name = 'JsonParseError';\n        this.url = url;\n    }\n}\n/**\n * AbortManager class to handle more AbortControllers.\n * @see AbortController {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortController}\n */\nexport class AbortManager {\n    /**\n     */\n    constructor() {\n        this.controllers = new Map();\n    }\n    /**\n     * Creates a new AbortController for a fetch request identified by a Unique Id.\n     *\n     * @param {string} uniqueId - Unique Id (or identifier)\n     * @returns {AbortController.AbortSignal}  - This signal can be passed to the asynchronous request.\n     */\n    createSignal(uniqueId) {\n        const controller = new AbortController();\n        this.controllers.set(uniqueId, controller);\n        return controller.signal;\n    }\n    /**\n     * Local abort operation.\n     * Aborts the operation associated with the Unique Id.\n     *\n     * @param {string} uniqueId - (optional) Unique Id (or identifier)\n     */\n    abort(uniqueId) {\n        const controller = this.controllers.get(uniqueId);\n        if (controller) {\n            controller.abort();\n            this.controllers.delete(uniqueId);\n        }\n    }\n    /**\n     * Global abort operation.\n     * Aborts all running and pending requests.\n     */\n    abortAll() {\n        this.controllers.forEach((controller) => controller.abort());\n        this.controllers.clear();\n    }\n}\n/**\n * ConcurrentFetcher class, which manages concurrent fetch requests and cancellation.\n *\n * Built upon:\n * - Fetch API {@link https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API}\n * - and AbortController {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortController}\n * @see Fetch API {@link https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API}\n * @see AbortController {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortController}\n */\nexport class ConcurrentFetcher {\n    //private commonErrors = {\n    //  invalidOperation: 'Invalid operation',\n    //  unAuthorized: 'You are not authorized to use this function',\n    //};\n    /**\n     * @param {array} requests - An array of:\n     * - URL: the URL (or resource) for the fetch request. This can be any one of:\n     *   - a string containing the URL\n     *   - an object, such an instance of URL, which has a stringifier that produces a string containing the URL\n     *   - a Request instance\n     * - (optional) fetch options: an object containing options to configure the request.\n     * - (optional) callback object: callback for the response handling:\n     *   - uniqueId: Either the supplied Request Id or the generated Id.\n     *   - data: result from the request. Is null when an error is raised.\n     *   - error: If not null, then an error have occurred for that request\n     *   - abortManager: Only to be used when aborting all subsequent fetch processing: abortManager.abortAll();\n     * - (optional) Request Id: Must identify each request uniquely. Required for error handling and for the caller or callback to navigate.\n     *   - Generated if not given. Known as uniqueId throughout the solution.\n     * - (optional) maxRetries: failed requests will retry up to maxRetries times with a retryDelay between each retry. Defaults to 0 (zero) meaning no retries.\n     * - (optional) statusCodesToRetry: The HTTP response status codes that will automatically be retried.\n     *   - Defaults to: [[100, 199], [429, 429], [500, 599]]\n     * - (optional) retryDelay: delay in ms between each retry. Defaults to 1000 = 1 second.\n     * - (optional) abortTimeout: automatically abort the request after this specified time (in ms).\n     * - (optional) forceReader: Reads response.body instead of either text, json or blob data. Defaults to false. See also cutoffAmount.\n     * - (optional) cutoffAmount: when response content is bigger than cutoffAmount (in KB!) - then response.body will be read in chunks. AND The result will be a blob object (even when reading text and json!). Defaults to 0 (zero) - meaning: no special treatment.\n     *   - blob data will be read in chunks if either forceReader (is true) or cutoffAmount (is reached).\n     *   - text/json data will be read in chunks if forceReader (is true) and returned as a string.\n     *   - text/json data will be read in chunks if cutoffAmount (is reached) and returned as blob data.\n     */\n    constructor(requests) {\n        if (!Array.isArray(requests)) {\n            throw this.CommonError('InvalidArgument', 'requests');\n        }\n        const reqLen = requests.length;\n        if (reqLen < 1) {\n            throw this.CommonError('ArgumentEmpty', 'requests');\n        }\n        const reqArray = [];\n        for (let i = 0; i < reqLen; i++) {\n            reqArray.push(i);\n        }\n        for (let i = 0; i < reqLen; i++) {\n            if (requests[i].requestId) {\n                if (reqArray.includes(requests[i].requestId)) {\n                    throw this.CommonError('DuplicateKey', 'requestId = ' + requests[i].requestId);\n                }\n                else {\n                    reqArray.push(requests[i].requestId);\n                }\n            }\n        }\n        this.requests = requests;\n        this.errors = [];\n        this.abortManager = new AbortManager();\n    }\n    /**\n     * Helper method to introduce a delay (in milliseconds)\n     */\n    delay(ms) {\n        return new Promise((resolve) => setTimeout(resolve, ms));\n    }\n    /**\n     * Retry logic for each individual fetch request\n     */\n    async fetchWithRetry(url, fetchWithSignal, uniqueId, maxRetries, statusCodesToRetry, retryDelay, forceReader, cutoffAmount, progressCallback, countRetries = 0) {\n        let responseStatus = 200;\n        try {\n            const _url = typeof Request !== 'undefined' && url instanceof Request\n                ? url.clone()\n                : url;\n            const response = await fetch(_url, fetchWithSignal);\n            ////console.log(\"response.statusText =\", response.statusText);\n            ////console.log(\"response.userFinalURL =\", response.useFinalURL);\n            responseStatus = response.status;\n            if (!response.ok) {\n                throw new FetchError('Fetch HTTP error! status: ' + response.status, url, response.status);\n            }\n            let contentType = '';\n            let contentLength = 0;\n            if (response.headers) {\n                response.headers.forEach((value, key) => {\n                    //console.log(\"response.header =\", `${key} ==> ${value}`);\n                    if (key.toLowerCase() == 'content-type') {\n                        contentType = value.toLowerCase();\n                    }\n                    else if (key.toLowerCase() == 'content-length') {\n                        contentLength = parseInt(value);\n                    }\n                });\n            }\n            let forceResponseReader = false;\n            if (forceReader && !response.bodyUsed && response.body) {\n                forceResponseReader = true;\n            }\n            let returnData;\n            if (contentType.match(/application\\/[^+]*[+]?(json);?.*/i)) {\n                if (forceResponseReader) {\n                    if (cutoffAmount > 0 &&\n                        contentLength > cutoffAmount * 1024 &&\n                        !response.bodyUsed &&\n                        response.body) {\n                        returnData = await this.fetchBlobStream(response, uniqueId, contentType, contentLength, progressCallback);\n                        //const resp = await this.fetchBlobStream(response, uniqueId, contentType, contentLength, progressCallback);\n                        //data = await resp.blob();\n                    }\n                    else {\n                        returnData = await this.fetchTextStream(response, 'json', uniqueId, contentType, contentLength, progressCallback);\n                    }\n                }\n                else {\n                    returnData = await response.json();\n                }\n            }\n            else if (contentType.includes('text/')) {\n                if (forceResponseReader) {\n                    if (cutoffAmount > 0 &&\n                        contentLength > cutoffAmount * 1024 &&\n                        !response.bodyUsed &&\n                        response.body) {\n                        returnData = await this.fetchBlobStream(response, uniqueId, contentType, contentLength, progressCallback);\n                        //const resp = await this.fetchBlobStream(response, uniqueId, contentType, contentLength, progressCallback);\n                        //data = await resp.blob();\n                    }\n                    else {\n                        returnData = await this.fetchTextStream(response, 'text', uniqueId, contentType, contentLength, progressCallback);\n                    }\n                }\n                else {\n                    returnData = await response.text();\n                }\n            }\n            else {\n                // blob!\n                if (forceResponseReader ||\n                    (cutoffAmount > 0 &&\n                        contentLength > cutoffAmount * 1024 &&\n                        !response.bodyUsed &&\n                        response.body)) {\n                    returnData = await this.fetchBlobStream(response, uniqueId, contentType, contentLength, progressCallback);\n                    //const resp = await this.fetchBlobStream(response, uniqueId, contentType, contentLength, progressCallback);\n                    //data = await resp.blob();\n                }\n                else {\n                    returnData = await response.blob();\n                }\n            }\n            return returnData;\n            //throw new FetchError('Should never happen', url, 0);\n        }\n        catch (err) {\n            if (this.shouldRetryRequest(responseStatus, maxRetries, statusCodesToRetry, countRetries)) {\n                countRetries++;\n                // Wait before retrying\n                await this.delay(retryDelay);\n                // Retry request.\n                return this.fetchWithRetry(url, fetchWithSignal, uniqueId, maxRetries, statusCodesToRetry, retryDelay, forceReader, cutoffAmount, progressCallback, countRetries);\n            }\n            else {\n                // Can't do more...\n                throw err;\n            }\n        }\n    }\n    /**\n     * This is the core method that performs concurrent fetching.\n     * @param {callback} progressCallback - (optional):\n     * - progressCallback?:\n     *   - uniqueId: string\n     *   - completedRequestCount: number\n     *   - totalRequestCount: number\n     * @returns {Promise<ConcurrentFetchResponse>} - A Promise of an array of ConcurrentFetchResponse: results and errors:\n     * - ConcurrentFetchResponse[]:\n     *  - results: any[];\n     *  - errors: { uniqueId: string; url: string | Request; error: Error }[];\n     */\n    async concurrentFetch({ progressCallback, } = {}) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const results = [];\n        let completedCount = 0;\n        const fetchPromises = this.requests.map((request, index) => {\n            const { url, fetchOptions = {}, callback = null, requestId = null, maxRetries = 0, statusCodesToRetry = [[100 - 199], [429 - 429], [500 - 599]], retryDelay = 1000, abortTimeout = 0, forceReader = false, cutoffAmount = 0, } = request;\n            const uniqueId = requestId !== null && requestId !== void 0 ? requestId : index.toString();\n            const abortSignal = abortTimeout > 0\n                ? AbortSignal.any([\n                    this.abortManager.createSignal(uniqueId),\n                    AbortSignal.timeout(abortTimeout),\n                ])\n                : this.abortManager.createSignal(uniqueId);\n            // Default options (can be overridden)\n            // including Representation header: Content-Type\n            const defaultOptions = {\n                method: 'GET',\n                headers: {\n                    Accept: 'application/json',\n                    'Content-Type': 'application/json; charset: UTF-8',\n                },\n                signal: abortSignal,\n            };\n            const fetchWithSignal = { ...defaultOptions, ...fetchOptions }; // signal: abortSignal\n            // Must remove 'Content-Type': 'multipart/form-data', since server expects:\n            // Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryyEmKNDsBKjB7QEqu\n            return this.fetchWithRetry(url, fetchWithSignal, uniqueId, maxRetries, statusCodesToRetry, retryDelay, forceReader, cutoffAmount, progressCallback)\n                .then((data) => {\n                if (callback) {\n                    callback(uniqueId, data, null, this.abortManager);\n                }\n                else {\n                    results[index] = data;\n                }\n            })\n                .catch((err) => {\n                if (err instanceof SyntaxError ||\n                    (err.name && err.name === 'SyntaxError')) {\n                    err = new JsonParseError(err.message, url);\n                    //} else if ((err instanceof TypeError) || (err.name && err.name === \"TypeError\")) {\n                    //  err = new FetchError('Fetch Network error! error: '+err.message, url, 500);\n                }\n                if (callback) {\n                    callback(uniqueId, null, err, this.abortManager);\n                }\n                else {\n                    this.errors.push({ uniqueId, url, error: err });\n                    results[index] = null;\n                }\n            })\n                .finally(() => {\n                completedCount++;\n                if (progressCallback) {\n                    progressCallback(uniqueId, completedCount, this.requests.length, 0, 0);\n                }\n            });\n        });\n        try {\n            await Promise.all(fetchPromises);\n            const filteredResults = results\n                ? results.filter((result) => result !== null)\n                : [];\n            return { results: filteredResults, errors: this.errors };\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (err) {\n            this.errors.push({ uniqueId: 'unknown', url: 'unknown', error: err });\n            this.requests.forEach((request) => {\n                var _a, _b;\n                return (_a = request.callback) === null || _a === void 0 ? void 0 : _a.call(request, (_b = request.requestId) !== null && _b !== void 0 ? _b : 'unknown', null, err, this.abortManager);\n            });\n            return { results: [], errors: this.errors };\n        }\n    }\n    /**\n     *  Reads text-/json-data in chunks.\n     *\n     */\n    async fetchTextStream(fetchResponse, fetchType, uniqueId, contentType, contentLength, progressCallback) {\n        if (!fetchResponse.body) {\n            throw new Error('Response body is empty.');\n        }\n        const reader = fetchResponse.body.getReader();\n        let done, value;\n        let textChunks = '';\n        const decoder = new TextDecoder('utf-8');\n        while (({ done, value } = await reader.read()), !done) {\n            textChunks += decoder.decode(value, { stream: true });\n            if (progressCallback) {\n                progressCallback(uniqueId, 0, 0, textChunks.length, contentLength);\n            }\n        }\n        // empty buffer...\n        textChunks += decoder.decode();\n        if (progressCallback) {\n            progressCallback(uniqueId, 0, 0, textChunks.length, contentLength);\n        }\n        if (fetchType == 'json') {\n            try {\n                return JSON.parse(textChunks);\n            }\n            catch (err) {\n                // If not JsonParseError re-throw, otherwise return textChunks...\n                if (!(err instanceof SyntaxError)) {\n                    throw err;\n                }\n            }\n        }\n        return textChunks;\n    }\n    /**\n     *  Reads blob-data in chunks.\n     *\n     */\n    async fetchBlobStream(fetchResponse, uniqueId, contentType, contentLength, progressCallback) {\n        if (!fetchResponse.body) {\n            throw new Error('Response body is empty.');\n        }\n        //console.log(\"fetchBlobStream =\", `${contentType} ==> ${contentLength}`);\n        const reader = fetchResponse.body.getReader();\n        const chunks = [];\n        let receivedLength = 0;\n        try {\n            //const allChunks = new Uint8Array(contentLength);\n            //let receivedLength = 0;\n            //while (true) {\n            //    const { done, value } = await reader.read();\n            //    if (done) { break; }\n            //    allChunks.set(value, receivedLength);\n            //    receivedLength += value.length;\n            //    if (progressCallback) { progressCallback(uniqueId, 0, 0, receivedLength, contentLength); }\n            //}\n            while (true) {\n                const { done, value } = await reader.read();\n                if (done) {\n                    break;\n                }\n                chunks.push(value);\n                receivedLength += value.length;\n                if (progressCallback) {\n                    progressCallback(uniqueId, 0, 0, receivedLength, contentLength);\n                }\n            }\n            const allChunks = new Uint8Array(receivedLength);\n            let position = 0;\n            for (const chunk of chunks) {\n                allChunks.set(chunk, position);\n                position += chunk.length;\n            }\n            //console.log(Date.now() + \" - blob is streamed: \" + receivedLength + \"/\" + contentLength);\n            return new Blob([allChunks]);\n            //return new Response(allChunks, {\n            //   status: fetchResponse.status,\n            //   statusText: fetchResponse.statusText,\n            //   headers: fetchResponse.headers\n            //});\n            //} catch(err) {\n            //    throw err;\n        }\n        finally {\n            reader.releaseLock();\n        }\n    }\n    /**\n     *  Check whether or not a retry-condition is met.\n     *  Based on the response.status and the statusCodesToRetry configured.\n     *\n     */\n    shouldRetryRequest(responseStatus, maxRetries, statusCodesToRetry, countRetries) {\n        if (maxRetries - countRetries < 1) {\n            return false;\n        }\n        let isInRange = false;\n        for (const [min, max] of statusCodesToRetry) {\n            if (responseStatus >= min && responseStatus <= max) {\n                isInRange = true;\n                break;\n            }\n        }\n        return isInRange;\n    }\n    /**\n     * Calls AbortManager.abort()\n     * see {@link AbortManager}\n     *\n     */\n    abort(uniqueId) {\n        this.abortManager.abort(uniqueId);\n    }\n    /**\n     * Calls AbortManager.abortAll()\n     * see {@link AbortManager}\n     */\n    abortAll() {\n        this.abortManager.abortAll();\n    }\n    /**\n     * Returns a new Error with a common error message.\n     */\n    CommonError(errorType, message) {\n        let errorMessage = '';\n        switch (errorType) {\n            case 'ArgumentEmpty':\n                errorMessage = 'Argument empty: ' + message;\n                break;\n            case 'ArgumentMissing':\n                errorMessage = 'Argument missing: ' + message;\n                break;\n            case 'InvalidArgument':\n                errorMessage = 'Argument is invalid: ' + message;\n                break;\n            case 'DuplicateKey':\n                errorMessage = 'Duplicate key: ' + message;\n                break;\n            case 'ValueError':\n                errorMessage = 'Value error: ' + message;\n                break;\n            default:\n                errorMessage = message;\n        }\n        const error = new Error(errorMessage);\n        error.name = errorType;\n        return error;\n    }\n}\n"],"names":[],"mappings":"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"}