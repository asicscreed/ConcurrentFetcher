'use strict';(function(u,w){"object"===typeof exports&&"undefined"!==typeof module?w(exports):"function"===typeof define&&define.amd?define(["exports"],w):(u="undefined"!==typeof globalThis?globalThis:u||self,w(u.ConcurrentFetcher={}))})(this,function(u){class w extends Error{constructor(b,a,e){super(b);this.name="FetchError";this.url=a;this.status=e}}class B extends SyntaxError{constructor(b,a){super(b);this.name="JsonParseError";this.url=a}}class C{constructor(){this.controllers=new Map}createSignal(b){const a=
new AbortController;this.controllers.set(b,a);return a.signal}abort(b){const a=this.controllers.get(b);a&&(a.abort(),this.controllers.delete(b))}abortAll(){this.controllers.forEach(b=>b.abort());this.controllers.clear()}}class D{constructor(b){if(!Array.isArray(b))throw this.CommonError("InvalidArgument","requests");const a=b.length;if(1>a)throw this.CommonError("ArgumentEmpty","requests");const e=[];for(var f=0;f<a;f++)e.push(f);for(f=0;f<a;f++)if(b[f].requestId){if(e.includes(b[f].requestId))throw this.CommonError("DuplicateKey",
"requestId = "+b[f].requestId);e.push(b[f].requestId)}this.requests=b;this.abortManager=new C;this.firstErrorRaised=null}delay(b){return new Promise(a=>setTimeout(a,b))}async fetchWithRetry(b,a,e,f,k,g,l,c,h,p=0){let x=200;try{var v="undefined"!==typeof Request&&b instanceof Request?b.clone():b;const d=await fetch(v,a);x=d.status;if(!d.ok)throw new w("Fetch HTTP error! status: "+d.status,b,d.status);let r="",m=0;d.headers&&d.headers.forEach((y,z)=>{"content-type"==z.toLowerCase()?r=y.toLowerCase():
"content-length"==z.toLowerCase()&&(m=parseInt(y))});v=!1;l&&!d.bodyUsed&&d.body&&(v=!0);return r.match(/application\/[^+]*[+]?(json);?.*/i)?v?0<c&&m>1024*c&&!d.bodyUsed&&d.body?await this.fetchBlobStream(d,e,r,m,h):await this.fetchTextStream(d,"json",e,r,m,h):await d.json():r.includes("text/")?v?0<c&&m>1024*c&&!d.bodyUsed&&d.body?await this.fetchBlobStream(d,e,r,m,h):await this.fetchTextStream(d,"text",e,r,m,h):await d.text():v||0<c&&m>1024*c&&!d.bodyUsed&&d.body?await this.fetchBlobStream(d,e,r,
m,h):await d.blob()}catch(d){if(this.shouldRetryRequest(x,f,k,p))return p++,await this.delay(g),this.fetchWithRetry(b,a,e,f,k,g,l,c,h,p);throw d;}}async concurrentFetch({progressCallback:b,abortOnError:a}={}){let e=0;const f=null!==a&&void 0!==a?a:!1;let k=!1;this.firstErrorRaised=null;a=this.requests.map((g,l)=>{const {url:c,fetchOptions:h={},callback:p=null,requestId:x=null,maxRetries:v=0,statusCodesToRetry:d=[[-99],[0],[-99]],retryDelay:r=1E3,abortTimeout:m=0,forceReader:y=!1,cutoffAmount:z=0}=
g,t=null!==x&&void 0!==x?x:l.toString();g={method:"GET",headers:{Accept:"application/json","Content-Type":"application/json; charset: UTF-8"},signal:0<m?AbortSignal.any([this.abortManager.createSignal(t),AbortSignal.timeout(m)]):this.abortManager.createSignal(t),...h};return this.fetchWithRetry(c,g,t,v,d,r,y,z,b).then(n=>{var q=Date.now();q={id:t,stamp:q};if(p)try{p(t,n,null,this.abortManager)}catch(A){console.log("Callback failed:",A)}else q.data=n;return Promise.resolve(q)}).catch(n=>{var q;const A=
Date.now();k||(k=!0,this.firstErrorRaised={id:t,stamp:A,error:n,message:null!==(q=n.message)&&void 0!==q?q:"Error"});q={id:t,stamp:A};if(n instanceof SyntaxError||n.name&&"SyntaxError"===n.name)n=new B(n.message,c);if(p)try{p(t,null,n,this.abortManager)}catch(E){console.log("Callback failed:",E)}else q.error=n;f&&this.abortAll();return Promise.reject(q)}).finally(()=>{e++;b&&!k&&b(t,e,this.requests.length,0,0)})});try{return await Promise.allSettled(a)}catch(g){throw k=!0,this.abortAll(),this.requests.forEach(l=>
{var c,h;return null===(c=l.callback)||void 0===c?void 0:c.call(l,null!==(h=l.requestId)&&void 0!==h?h:"unknown",null,g,this.abortManager)}),g;}}async fetchTextStream(b,a,e,f,k,g){if(!b.body)throw Error("Response body is empty.");b=b.body.getReader();let l,c="";const h=new TextDecoder("utf-8");for(;{done:l,value:f}=await b.read(),!l;)c+=h.decode(f,{stream:!0}),g&&g(e,0,0,c.length,k);c+=h.decode();g&&g(e,0,0,c.length,k);if("json"==a)try{return JSON.parse(c)}catch(p){if(!(p instanceof SyntaxError))throw p;
}return c}async fetchBlobStream(b,a,e,f,k){if(!b.body)throw Error("Response body is empty.");b=b.body.getReader();e=[];let g=0;try{for(;;){const {done:c,value:h}=await b.read();if(c)break;e.push(h);g+=h.length;k&&k(a,0,0,g,f)}const l=new Uint8Array(g);a=0;for(const c of e)l.set(c,a),a+=c.length;return new Blob([l])}finally{b.releaseLock()}}getErrorRaised(){return this.firstErrorRaised}shouldRetryRequest(b,a,e,f){if(1>a-f)return!1;a=!1;for(const [k,g]of e)if(b>=k&&b<=g){a=!0;break}return a}abort(b){this.abortManager.abort(b)}abortAll(){this.abortManager.abortAll()}CommonError(b,
a){switch(b){case "ArgumentEmpty":a="Argument empty: "+a;break;case "ArgumentMissing":a="Argument missing: "+a;break;case "InvalidArgument":a="Argument is invalid: "+a;break;case "DuplicateKey":a="Duplicate key: "+a;break;case "ValueError":a="Value error: "+a}a=Error(a);a.name=b;return a}}u.AbortManager=C;u.ConcurrentFetcher=D;u.FetchError=w;u.JsonParseError=B});
