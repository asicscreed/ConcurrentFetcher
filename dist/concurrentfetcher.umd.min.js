'use strict';(function(l,q){"object"===typeof exports&&"undefined"!==typeof module?q(exports):"function"===typeof define&&define.amd?define(["exports"],q):(l="undefined"!==typeof globalThis?globalThis:l||self,q(l.ConcurrentFetcher={}))})(this,function(l){class q extends Error{constructor(a,b,m){super(a);this.name="FetchError";this.url=b;this.status=m}}class z extends Error{constructor(a,b){super(a);this.name="JsonParseError";this.url=b}}class A{constructor(){this.controllers=new Map}createSignal(a){const b=
new AbortController;this.controllers.set(a,b);return b.signal}abort(a){const b=this.controllers.get(a);b&&(b.abort(),this.controllers.delete(a))}abortAll(){this.controllers.forEach(a=>a.abort());this.controllers.clear()}}class C{constructor(a){this.requests=a;this.errors=[];this.abortManager=new A}delay(a){return new Promise(b=>setTimeout(b,a))}async fetchWithRetry(a,b,m,r,f,g,h,k,n=0){let t=200;try{var u="undefined"!==typeof Request&&a instanceof Request?a.clone():a,c=await fetch(u,b);t=c.status;
if(!c.ok)throw new q("Fetch HTTP error! status: "+c.status,a,c.status);let p="",v=0;c.headers&&c.headers.forEach((d,x)=>{"content-type"==x.toLowerCase()?p=d.toLowerCase():"content-length"==x.toLowerCase()&&(v=parseInt(d))});let e;if(p.includes("application/json")){var w=c.clone();try{e=await c.json()}catch(d){e=await w.text()}}else if(p.includes("text/"))e=await c.text();else if(0<h&&v>h&&!c.bodyUsed&&c.body){const d=c.body.getReader();u=[];c=0;try{for(;;){const {done:y,value:B}=await d.read();if(y)break;
u.push(B);c+=B.length;k&&k(0,0,c,v)}const x=new Uint8Array(c);w=0;for(const y of u)x.set(y,w),w+=y.length;e=x;console.log(Date.now()+" - blob is streamed: "+c+"/"+v)}finally{d.releaseLock()}}else e=await c.blob();return e}catch(p){if(this.shouldRetryRequest(t,r,f,n))return n++,await this.delay(g),this.fetchWithRetry(a,b,m,r,f,g,h,k,n);throw p;}}async concurrentFetch({progressCallback:a}={}){const b=[];let m=0;const r=this.requests.map((f,g)=>{const {url:h,fetchOptions:k={},callback:n=null,requestId:t=
null,maxRetries:u=0,statusCodesToRetry:c=[[-99],[0],[-99]],retryDelay:w=1E3,abortTimeout:p=0,cutoffAmount:v=0}=f,e=null!==t&&void 0!==t?t:g.toString();f={method:"GET",headers:{Accept:"application/json","Content-Type":"application/json; charset: UTF-8"},signal:0<p?AbortSignal.any([this.abortManager.createSignal(e),AbortSignal.timeout(p)]):this.abortManager.createSignal(e),...k};return this.fetchWithRetry(h,f,e,u,c,w,v,a).then(d=>{n?n(e,d,null,this.abortManager):b[g]=d}).catch(d=>{d instanceof SyntaxError&&
(d=new z(d.message,h));n?n(e,null,d,this.abortManager):(this.errors.push({uniqueId:e,url:h,error:d}),b[g]=null)}).finally(()=>{m++;a&&a(e,m,this.requests.length,0,0)})});try{return await Promise.all(r),{results:b?b.filter(f=>null!==f):[],errors:this.errors}}catch(f){return this.errors.push({uniqueId:"unknown",url:"unknown",error:f}),this.requests.forEach(g=>{var h,k;return null===(h=g.callback)||void 0===h?void 0:h.call(g,null!==(k=g.requestId)&&void 0!==k?k:"unknown",null,f,this.abortManager)}),
{results:[],errors:this.errors}}}shouldRetryRequest(a,b,m,r){if(1>b-r)return!1;b=!1;for(const [f,g]of m)if(a>=f&&a<=g){b=!0;break}return b}abort(a){this.abortManager.abort(a)}abortAll(){this.abortManager.abortAll()}}l.AbortManager=A;l.ConcurrentFetcher=C;l.FetchError=q;l.JsonParseError=z});
