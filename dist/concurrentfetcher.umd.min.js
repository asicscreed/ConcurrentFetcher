'use strict';(function(u,w){"object"===typeof exports&&"undefined"!==typeof module?w(exports):"function"===typeof define&&define.amd?define(["exports"],w):(u="undefined"!==typeof globalThis?globalThis:u||self,w(u.ConcurrentFetcher={}))})(this,function(u){class w extends Error{constructor(b,a,e){super(b);this.name="FetchError";this.url=a;this.status=e}}class B extends SyntaxError{constructor(b,a){super(b);this.name="JsonParseError";this.url=a}}class C{constructor(){this.controllers=new Map}createSignal(b){const a=
new AbortController;this.controllers.set(b,a);return a.signal}abort(b){const a=this.controllers.get(b);a&&(a.abort(),this.controllers.delete(b))}abortAll(){this.controllers.forEach(b=>b.abort());this.controllers.clear()}}class D{constructor(b){if(!Array.isArray(b))throw this.CommonError("InvalidArgument","requests");const a=b.length;if(1>a)throw this.CommonError("ArgumentEmpty","requests");const e=[];for(var f=0;f<a;f++)e.push(f);for(f=0;f<a;f++)if(b[f].requestId){if(e.includes(b[f].requestId))throw this.CommonError("DuplicateKey",
"requestId = "+b[f].requestId);e.push(b[f].requestId)}this.requests=b;this.abortManager=new C;this.firstErrorRaised=null}delay(b){return new Promise(a=>setTimeout(a,b))}async fetchWithRetry(b,a,e,f,l,g,m,c,h,k=0){let x=200;try{var v="undefined"!==typeof Request&&b instanceof Request?b.clone():b;const d=await fetch(v,a);x=d.status;if(!d.ok)throw new w("Fetch HTTP error! status: "+d.status,b,d.status);let r="",p=0;d.headers&&d.headers.forEach((y,z)=>{"content-type"==z.toLowerCase()?r=y.toLowerCase():
"content-length"==z.toLowerCase()&&(p=parseInt(y))});v=!1;m&&!d.bodyUsed&&d.body&&(v=!0);return r.match(/application\/[^+]*[+]?(json);?.*/i)?v?0<c&&p>1024*c&&!d.bodyUsed&&d.body?await this.fetchBlobStream(d,e,r,p,h):await this.fetchTextStream(d,"json",e,r,p,h):await d.json():r.includes("text/")?v?0<c&&p>1024*c&&!d.bodyUsed&&d.body?await this.fetchBlobStream(d,e,r,p,h):await this.fetchTextStream(d,"text",e,r,p,h):await d.text():v||0<c&&p>1024*c&&!d.bodyUsed&&d.body?await this.fetchBlobStream(d,e,r,
p,h):await d.blob()}catch(d){if(this.shouldRetryRequest(x,f,l,k))return k++,await this.delay(g),this.fetchWithRetry(b,a,e,f,l,g,m,c,h,k);throw d;}}async concurrentFetch({progressCallback:b,abortOnError:a}={}){let e=0;const f=null!==a&&void 0!==a?a:!1;let l=!1;this.firstErrorRaised=null;a=this.requests.map((g,m)=>{const {url:c,fetchOptions:h={},callback:k=null,requestId:x=null,maxRetries:v=0,statusCodesToRetry:d=[[-99],[0],[-99]],retryDelay:r=1E3,abortTimeout:p=0,forceReader:y=!1,cutoffAmount:z=0}=
g,t=x?x.toString():m.toString();g={method:"GET",headers:{Accept:"application/json","Content-Type":"application/json; charset: UTF-8"},signal:0<p?AbortSignal.any([this.abortManager.createSignal(t),AbortSignal.timeout(p)]):this.abortManager.createSignal(t),...h};return this.fetchWithRetry(c,g,t,v,d,r,y,z,b).then(n=>{var q=Date.now();q={id:t,stamp:q};if(k)try{k(t,n,null,this.abortManager)}catch(A){console.log("Callback failed:",A)}else q.data=n;return Promise.resolve(q)}).catch(n=>{var q;const A=Date.now();
l||(l=!0,this.firstErrorRaised={id:t,stamp:A,error:n,message:null!==(q=n.message)&&void 0!==q?q:"Error"});q={id:t,stamp:A};if(n instanceof SyntaxError||n.name&&"SyntaxError"===n.name)n=new B(n.message,c);if(k)try{k(t,null,n,this.abortManager)}catch(E){console.log("Callback failed:",E)}else q.error=n;f&&this.abortAll();return Promise.reject(q)}).finally(()=>{e++;if(b&&!l)try{b(t,e,this.requests.length,0,0)}catch(n){console.log("ProgressCallback failed: ",n)}})});try{return await Promise.allSettled(a)}catch(g){throw l=
!0,this.abortAll(),this.requests.forEach(m=>{var c,h;return null===(c=m.callback)||void 0===c?void 0:c.call(m,null!==(h=m.requestId)&&void 0!==h?h:"unknown",null,g,this.abortManager)}),g;}}async fetchTextStream(b,a,e,f,l,g){if(!b.body)throw Error("Response body is empty.");b=b.body.getReader();let m,c="";const h=new TextDecoder("utf-8");for(;{done:m,value:f}=await b.read(),!m;)if(c+=h.decode(f,{stream:!0}),g)try{g(e,0,0,c.length,l)}catch(k){console.log("ProgressCallback failed: ",k)}c+=h.decode();
if(g)try{g(e,0,0,c.length,l)}catch(k){console.log("ProgressCallback failed: ",k)}if("json"==a)try{return JSON.parse(c)}catch(k){if(!(k instanceof SyntaxError))throw k;}return c}async fetchBlobStream(b,a,e,f,l){if(!b.body)throw Error("Response body is empty.");b=b.body.getReader();e=[];let g=0;try{for(;;){const {done:c,value:h}=await b.read();if(c)break;e.push(h);g+=h.length;if(l)try{l(a,0,0,g,f)}catch(k){console.log("ProgressCallback failed: ",k)}}const m=new Uint8Array(g);a=0;for(const c of e)m.set(c,
a),a+=c.length;return new Blob([m])}finally{b.releaseLock()}}getErrorRaised(){return this.firstErrorRaised}shouldRetryRequest(b,a,e,f){if(1>a-f)return!1;a=!1;for(const [l,g]of e)if(b>=l&&b<=g){a=!0;break}return a}abort(b){this.abortManager.abort(b)}abortAll(){this.abortManager.abortAll()}CommonError(b,a){switch(b){case "ArgumentEmpty":a="Argument empty: "+a;break;case "ArgumentMissing":a="Argument missing: "+a;break;case "InvalidArgument":a="Argument is invalid: "+a;break;case "DuplicateKey":a="Duplicate key: "+
a;break;case "ValueError":a="Value error: "+a}a=Error(a);a.name=b;return a}}u.AbortManager=C;u.ConcurrentFetcher=D;u.FetchError=w;u.JsonParseError=B});
