'use strict';class FetchError extends Error{constructor(b,a,e){super(b);this.name="FetchError";this.url=a;this.status=e}}class JsonParseError extends SyntaxError{constructor(b,a){super(b);this.name="JsonParseError";this.url=a}}
class AbortManager{constructor(){this.controllers=new Map}createSignal(b){const a=new AbortController;this.controllers.set(b,a);return a.signal}abort(b){const a=this.controllers.get(b);a&&(a.abort(),this.controllers.delete(b))}abortAll(){this.controllers.forEach(b=>b.abort());this.controllers.clear()}}
class ConcurrentFetcher{constructor(b){if(!Array.isArray(b))throw this.CommonError("InvalidArgument","requests");const a=b.length;if(1>a)throw this.CommonError("ArgumentEmpty","requests");const e=[];for(var f=0;f<a;f++)e.push(f);for(f=0;f<a;f++)if(b[f].requestId){if(e.includes(b[f].requestId))throw this.CommonError("DuplicateKey","requestId = "+b[f].requestId);e.push(b[f].requestId)}this.requests=b;this.abortManager=new AbortManager;this.firstErrorRaised=null}delay(b){return new Promise(a=>setTimeout(a,
b))}async fetchWithRetry(b,a,e,f,l,g,m,c,h,k=0){let v=200;try{var u="undefined"!==typeof Request&&b instanceof Request?b.clone():b;const d=await fetch(u,a);v=d.status;if(!d.ok)throw new FetchError("Fetch HTTP error! status: "+d.status,b,d.status);let r="",p=0;d.headers&&d.headers.forEach((w,x)=>{"content-type"==x.toLowerCase()?r=w.toLowerCase():"content-length"==x.toLowerCase()&&(p=parseInt(w))});u=!1;m&&!d.bodyUsed&&d.body&&(u=!0);return r.match(/application\/[^+]*[+]?(json);?.*/i)?u?0<c&&p>1024*
c&&!d.bodyUsed&&d.body?await this.fetchBlobStream(d,e,r,p,h):await this.fetchTextStream(d,"json",e,r,p,h):await d.json():r.includes("text/")?u?0<c&&p>1024*c&&!d.bodyUsed&&d.body?await this.fetchBlobStream(d,e,r,p,h):await this.fetchTextStream(d,"text",e,r,p,h):await d.text():u||0<c&&p>1024*c&&!d.bodyUsed&&d.body?await this.fetchBlobStream(d,e,r,p,h):await d.blob()}catch(d){if(this.shouldRetryRequest(v,f,l,k))return k++,await this.delay(g),this.fetchWithRetry(b,a,e,f,l,g,m,c,h,k);throw d;}}async concurrentFetch({progressCallback:b,
abortOnError:a}={}){let e=0;const f=null!==a&&void 0!==a?a:!1;let l=!1;this.firstErrorRaised=null;a=this.requests.map((g,m)=>{const {url:c,fetchOptions:h={},callback:k=null,requestId:v=null,maxRetries:u=0,statusCodesToRetry:d=[[-99],[0],[-99]],retryDelay:r=1E3,abortTimeout:p=0,forceReader:w=!1,cutoffAmount:x=0}=g,t=v?v.toString():m.toString();g={method:"GET",headers:{Accept:"application/json","Content-Type":"application/json; charset: UTF-8"},signal:0<p?AbortSignal.any([this.abortManager.createSignal(t),
AbortSignal.timeout(p)]):this.abortManager.createSignal(t),...h};return this.fetchWithRetry(c,g,t,u,d,r,w,x,b).then(n=>{var q=Date.now();q={id:t,stamp:q};if(k)try{k(t,n,null,this.abortManager)}catch(y){console.log("Callback failed:",y)}else q.data=n;return Promise.resolve(q)}).catch(n=>{var q;const y=Date.now();l||(l=!0,this.firstErrorRaised={id:t,stamp:y,error:n,message:null!==(q=n.message)&&void 0!==q?q:"Error"});q={id:t,stamp:y};if(n instanceof SyntaxError||n.name&&"SyntaxError"===n.name)n=new JsonParseError(n.message,
c);if(k)try{k(t,null,n,this.abortManager)}catch(z){console.log("Callback failed:",z)}else q.error=n;f&&this.abortAll();return Promise.reject(q)}).finally(()=>{e++;if(b&&!l)try{b(t,e,this.requests.length,0,0)}catch(n){console.log("ProgressCallback failed: ",n)}})});try{return await Promise.allSettled(a)}catch(g){throw l=!0,this.abortAll(),this.requests.forEach(m=>{var c,h;return null===(c=m.callback)||void 0===c?void 0:c.call(m,null!==(h=m.requestId)&&void 0!==h?h:"unknown",null,g,this.abortManager)}),
g;}}async fetchTextStream(b,a,e,f,l,g){if(!b.body)throw Error("Response body is empty.");b=b.body.getReader();let m,c="";const h=new TextDecoder("utf-8");for(;{done:m,value:f}=await b.read(),!m;)if(c+=h.decode(f,{stream:!0}),g)try{g(e,0,0,c.length,l)}catch(k){console.log("ProgressCallback failed: ",k)}c+=h.decode();if(g)try{g(e,0,0,c.length,l)}catch(k){console.log("ProgressCallback failed: ",k)}if("json"==a)try{return JSON.parse(c)}catch(k){if(!(k instanceof SyntaxError))throw k;}return c}async fetchBlobStream(b,
a,e,f,l){if(!b.body)throw Error("Response body is empty.");b=b.body.getReader();e=[];let g=0;try{for(;;){const {done:c,value:h}=await b.read();if(c)break;e.push(h);g+=h.length;if(l)try{l(a,0,0,g,f)}catch(k){console.log("ProgressCallback failed: ",k)}}const m=new Uint8Array(g);a=0;for(const c of e)m.set(c,a),a+=c.length;return new Blob([m])}finally{b.releaseLock()}}getErrorRaised(){return this.firstErrorRaised}shouldRetryRequest(b,a,e,f){if(1>a-f)return!1;a=!1;for(const [l,g]of e)if(b>=l&&b<=g){a=
!0;break}return a}abort(b){this.abortManager.abort(b)}abortAll(){this.abortManager.abortAll()}CommonError(b,a){switch(b){case "ArgumentEmpty":a="Argument empty: "+a;break;case "ArgumentMissing":a="Argument missing: "+a;break;case "InvalidArgument":a="Argument is invalid: "+a;break;case "DuplicateKey":a="Duplicate key: "+a;break;case "ValueError":a="Value error: "+a}a=Error(a);a.name=b;return a}}exports.AbortManager=AbortManager;exports.ConcurrentFetcher=ConcurrentFetcher;exports.FetchError=FetchError;
exports.JsonParseError=JsonParseError;
