'use strict';class FetchError extends Error{constructor(b,a,e){super(b);this.name="FetchError";this.url=a;this.status=e}}class JsonParseError extends SyntaxError{constructor(b,a){super(b);this.name="JsonParseError";this.url=a}}
class AbortManager{constructor(){this.controllers=new Map}createSignal(b){const a=new AbortController;this.controllers.set(b,a);return a.signal}abort(b){const a=this.controllers.get(b);a&&(a.abort(),this.controllers.delete(b))}abortAll(){this.controllers.forEach(b=>b.abort());this.controllers.clear()}}
class ConcurrentFetcher{constructor(b){if(!Array.isArray(b))throw this.CommonError("InvalidArgument","requests");const a=b.length;if(1>a)throw this.CommonError("ArgumentEmpty","requests");const e=[];for(var f=0;f<a;f++)e.push(f);for(f=0;f<a;f++)if(b[f].requestId){if(e.includes(b[f].requestId))throw this.CommonError("DuplicateKey","requestId = "+b[f].requestId);e.push(b[f].requestId)}this.requests=b;this.abortManager=new AbortManager;this.firstErrorRaised=null}delay(b){return new Promise(a=>setTimeout(a,
b))}async fetchWithRetry(b,a,e,f,k,g,l,c,h,p=0){let v=200;try{var u="undefined"!==typeof Request&&b instanceof Request?b.clone():b;const d=await fetch(u,a);v=d.status;if(!d.ok)throw new FetchError("Fetch HTTP error! status: "+d.status,b,d.status);let r="",m=0;d.headers&&d.headers.forEach((w,x)=>{"content-type"==x.toLowerCase()?r=w.toLowerCase():"content-length"==x.toLowerCase()&&(m=parseInt(w))});u=!1;l&&!d.bodyUsed&&d.body&&(u=!0);return r.match(/application\/[^+]*[+]?(json);?.*/i)?u?0<c&&m>1024*
c&&!d.bodyUsed&&d.body?await this.fetchBlobStream(d,e,r,m,h):await this.fetchTextStream(d,"json",e,r,m,h):await d.json():r.includes("text/")?u?0<c&&m>1024*c&&!d.bodyUsed&&d.body?await this.fetchBlobStream(d,e,r,m,h):await this.fetchTextStream(d,"text",e,r,m,h):await d.text():u||0<c&&m>1024*c&&!d.bodyUsed&&d.body?await this.fetchBlobStream(d,e,r,m,h):await d.blob()}catch(d){if(this.shouldRetryRequest(v,f,k,p))return p++,await this.delay(g),this.fetchWithRetry(b,a,e,f,k,g,l,c,h,p);throw d;}}async concurrentFetch({progressCallback:b,
abortOnError:a}={}){let e=0;const f=null!==a&&void 0!==a?a:!1;let k=!1;this.firstErrorRaised=null;a=this.requests.map((g,l)=>{const {url:c,fetchOptions:h={},callback:p=null,requestId:v=null,maxRetries:u=0,statusCodesToRetry:d=[[-99],[0],[-99]],retryDelay:r=1E3,abortTimeout:m=0,forceReader:w=!1,cutoffAmount:x=0}=g,t=null!==v&&void 0!==v?v:l.toString();g={method:"GET",headers:{Accept:"application/json","Content-Type":"application/json; charset: UTF-8"},signal:0<m?AbortSignal.any([this.abortManager.createSignal(t),
AbortSignal.timeout(m)]):this.abortManager.createSignal(t),...h};return this.fetchWithRetry(c,g,t,u,d,r,w,x,b).then(n=>{var q=Date.now();q={id:t,stamp:q};if(p)try{p(t,n,null,this.abortManager)}catch(y){console.log("Callback failed:",y)}else q.data=n;return Promise.resolve(q)}).catch(n=>{var q;const y=Date.now();k||(k=!0,this.firstErrorRaised={id:t,stamp:y,error:n,message:null!==(q=n.message)&&void 0!==q?q:"Error"});q={id:t,stamp:y};if(n instanceof SyntaxError||n.name&&"SyntaxError"===n.name)n=new JsonParseError(n.message,
c);if(p)try{p(t,null,n,this.abortManager)}catch(z){console.log("Callback failed:",z)}else q.error=n;f&&this.abortAll();return Promise.reject(q)}).finally(()=>{e++;b&&!k&&b(t,e,this.requests.length,0,0)})});try{return await Promise.allSettled(a)}catch(g){throw k=!0,this.abortAll(),this.requests.forEach(l=>{var c,h;return null===(c=l.callback)||void 0===c?void 0:c.call(l,null!==(h=l.requestId)&&void 0!==h?h:"unknown",null,g,this.abortManager)}),g;}}async fetchTextStream(b,a,e,f,k,g){if(!b.body)throw Error("Response body is empty.");
b=b.body.getReader();let l,c="";const h=new TextDecoder("utf-8");for(;{done:l,value:f}=await b.read(),!l;)c+=h.decode(f,{stream:!0}),g&&g(e,0,0,c.length,k);c+=h.decode();g&&g(e,0,0,c.length,k);if("json"==a)try{return JSON.parse(c)}catch(p){if(!(p instanceof SyntaxError))throw p;}return c}async fetchBlobStream(b,a,e,f,k){if(!b.body)throw Error("Response body is empty.");b=b.body.getReader();e=[];let g=0;try{for(;;){const {done:c,value:h}=await b.read();if(c)break;e.push(h);g+=h.length;k&&k(a,0,0,g,
f)}const l=new Uint8Array(g);a=0;for(const c of e)l.set(c,a),a+=c.length;return new Blob([l])}finally{b.releaseLock()}}getErrorRaised(){return this.firstErrorRaised}shouldRetryRequest(b,a,e,f){if(1>a-f)return!1;a=!1;for(const [k,g]of e)if(b>=k&&b<=g){a=!0;break}return a}abort(b){this.abortManager.abort(b)}abortAll(){this.abortManager.abortAll()}CommonError(b,a){switch(b){case "ArgumentEmpty":a="Argument empty: "+a;break;case "ArgumentMissing":a="Argument missing: "+a;break;case "InvalidArgument":a=
"Argument is invalid: "+a;break;case "DuplicateKey":a="Duplicate key: "+a;break;case "ValueError":a="Value error: "+a}a=Error(a);a.name=b;return a}}exports.AbortManager=AbortManager;exports.ConcurrentFetcher=ConcurrentFetcher;exports.FetchError=FetchError;exports.JsonParseError=JsonParseError;
