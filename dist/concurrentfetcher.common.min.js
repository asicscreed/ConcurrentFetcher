'use strict';class FetchError extends Error{constructor(b,a,e){super(b);this.name="FetchError";this.url=a;this.status=e}}class JsonParseError extends SyntaxError{constructor(b,a){super(b);this.name="JsonParseError";this.url=a}}
class AbortManager{constructor(){this.controllers=new Map}createSignal(b){const a=new AbortController;this.controllers.set(b,a);return a.signal}abort(b){const a=this.controllers.get(b);a&&(a.abort(),this.controllers.delete(b))}abortAll(){this.controllers.forEach(b=>b.abort());this.controllers.clear()}}
class ConcurrentFetcher{constructor(b){this.commonErrors={invalidOperation:"Invalid operation",unAuthorized:"You are not authorized to use this function"};if(!Array.isArray(b))throw this.CommonError("InvalidArgument","requests");const a=b.length;if(1>a)throw this.CommonError("ArgumentEmpty","requests");const e=[];for(var f=0;f<a;f++)e.push(f);for(f=0;f<a;f++)if(b[f].requestId){if(e.includes(b[f].requestId))throw this.CommonError("DuplicateKey","requestId = "+b[f].requestId);e.push(b[f].requestId)}this.requests=
b;this.errors=[];this.abortManager=new AbortManager}delay(b){return new Promise(a=>setTimeout(a,b))}async fetchWithRetry(b,a,e,f,h,g,l,d,k,p=0){let u=200;try{var t="undefined"!==typeof Request&&b instanceof Request?b.clone():b;const c=await fetch(t,a);u=c.status;if(!c.ok)throw new FetchError("Fetch HTTP error! status: "+c.status,b,c.status);let m="",n=0;c.headers&&c.headers.forEach((v,q)=>{"content-type"==q.toLowerCase()?m=v.toLowerCase():"content-length"==q.toLowerCase()&&(n=parseInt(v))});t=!1;
l&&!c.bodyUsed&&c.body&&(t=!0);return m.match(/application\/[^+]*[+]?(json);?.*/i)?t?0<d&&n>1024*d&&!c.bodyUsed&&c.body?await this.fetchBlobStream(c,e,m,n,k):await this.fetchTextStream(c,"json",e,m,n,k):await c.json():m.includes("text/")?t?0<d&&n>1024*d&&!c.bodyUsed&&c.body?await this.fetchBlobStream(c,e,m,n,k):await this.fetchTextStream(c,"text",e,m,n,k):await c.text():t||0<d&&n>1024*d&&!c.bodyUsed&&c.body?await this.fetchBlobStream(c,e,m,n,k):await c.blob()}catch(c){if(this.shouldRetryRequest(u,
f,h,p))return p++,await this.delay(g),this.fetchWithRetry(b,a,e,f,h,g,l,d,k,p);throw c;}}async concurrentFetch({progressCallback:b}={}){const a=[];let e=0;const f=this.requests.map((h,g)=>{const {url:l,fetchOptions:d={},callback:k=null,requestId:p=null,maxRetries:u=0,statusCodesToRetry:t=[[-99],[0],[-99]],retryDelay:c=1E3,abortTimeout:m=0,forceReader:n=!1,cutoffAmount:v=0}=h,q=null!==p&&void 0!==p?p:g.toString();h={method:"GET",headers:{Accept:"application/json","Content-Type":"application/json; charset: UTF-8"},
signal:0<m?AbortSignal.any([this.abortManager.createSignal(q),AbortSignal.timeout(m)]):this.abortManager.createSignal(q),...d};return this.fetchWithRetry(l,h,q,u,t,c,n,v,b).then(r=>{k?k(q,r,null,this.abortManager):a[g]=r}).catch(r=>{if(r instanceof SyntaxError||r.name&&"SyntaxError"===r.name)r=new JsonParseError(r.message,l);k?k(q,null,r,this.abortManager):(this.errors.push({uniqueId:q,url:l,error:r}),a[g]=null)}).finally(()=>{e++;b&&b(q,e,this.requests.length,0,0)})});try{return await Promise.all(f),
{results:a?a.filter(h=>null!==h):[],errors:this.errors}}catch(h){return this.errors.push({uniqueId:"unknown",url:"unknown",error:h}),this.requests.forEach(g=>{var l,d;return null===(l=g.callback)||void 0===l?void 0:l.call(g,null!==(d=g.requestId)&&void 0!==d?d:"unknown",null,h,this.abortManager)}),{results:[],errors:this.errors}}}async fetchTextStream(b,a,e,f,h,g){if(!b.body)throw Error("Response body is empty.");b=b.body.getReader();let l,d="";const k=new TextDecoder("utf-8");for(;{done:l,value:f}=
await b.read(),!l;)d+=k.decode(f,{stream:!0}),g&&g(e,0,0,d.length,h);d+=k.decode();g&&g(e,0,0,d.length,h);if("json"==a)try{return JSON.parse(d)}catch(p){if(!(p instanceof SyntaxError))throw p;}return d}async fetchBlobStream(b,a,e,f,h){if(!b.body)throw Error("Response body is empty.");b=b.body.getReader();e=[];let g=0;try{for(;;){const {done:d,value:k}=await b.read();if(d)break;e.push(k);g+=k.length;h&&h(a,0,0,g,f)}const l=new Uint8Array(g);a=0;for(const d of e)l.set(d,a),a+=d.length;return new Blob([l])}finally{b.releaseLock()}}shouldRetryRequest(b,
a,e,f){if(1>a-f)return!1;a=!1;for(const [h,g]of e)if(b>=h&&b<=g){a=!0;break}return a}abort(b){this.abortManager.abort(b)}abortAll(){this.abortManager.abortAll()}CommonError(b,a){switch(b){case "ArgumentEmpty":a="Argument empty: "+a;break;case "ArgumentMissing":a="Argument missing: "+a;break;case "InvalidArgument":a="Argument is invalid: "+a;break;case "DuplicateKey":a="Duplicate key: "+a;break;case "ValueError":a="Value error: "+a}a=Error(a);a.name=b;return a}}exports.AbortManager=AbortManager;
exports.ConcurrentFetcher=ConcurrentFetcher;exports.FetchError=FetchError;exports.JsonParseError=JsonParseError;
