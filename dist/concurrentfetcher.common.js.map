{"version":3,"file":"concurrentfetcher.common.js","sources":["concurrentfetcher.js"],"sourcesContent":["/**\n * FetchError class to encapsulate fetch errors.\n */\nexport class FetchError extends Error {\n    /**\n     * @param {string} message - The Fetch request error message\n     * @param {string | Request} url - The url request that failed\n     * @param {number} status - The http error status\n     */\n    constructor(message, url, status) {\n        super(message);\n        //this.name = this.constructor.name; minified...\n        this.name = 'FetchError';\n        this.url = url;\n        this.status = status;\n    }\n}\n/**\n * JsonParseError class to encapsulate JSON parse errors.\n */\nexport class JsonParseError extends SyntaxError {\n    /**\n     * @param {string} message - The JSON parse error message\n     * @param {string | Request} url - The url request that failed\n     */\n    constructor(message, url) {\n        super(message);\n        //this.name = this.constructor.name; minified...\n        this.name = 'JsonParseError';\n        this.url = url;\n    }\n}\n/**\n * AbortManager class to handle more AbortControllers.\n * @see AbortController {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortController}\n */\nexport class AbortManager {\n    /**\n     */\n    constructor() {\n        this.controllers = new Map();\n    }\n    /**\n     * Creates a new AbortController for a fetch request identified by a Unique Id.\n     *\n     * @param {string} uniqueId - Unique Id (or identifier)\n     * @returns {AbortController.AbortSignal}  - This signal can be passed to the asynchronous request.\n     */\n    createSignal(uniqueId) {\n        const controller = new AbortController();\n        this.controllers.set(uniqueId, controller);\n        return controller.signal;\n    }\n    /**\n     * Local abort operation.\n     * Aborts the operation associated with the Unique Id.\n     *\n     * @param {string} uniqueId - (optional) Unique Id (or identifier)\n     */\n    abort(uniqueId) {\n        const controller = this.controllers.get(uniqueId);\n        if (controller) {\n            controller.abort();\n            this.controllers.delete(uniqueId);\n        }\n    }\n    /**\n     * Global abort operation.\n     * Aborts all running and pending requests.\n     */\n    abortAll() {\n        this.controllers.forEach((controller) => controller.abort());\n        this.controllers.clear();\n    }\n}\n/**\n * ConcurrentFetcher class, which manages concurrent fetch requests and cancellation.\n *\n * Built upon:\n * - Fetch API {@link https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API}\n * - and AbortController {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortController}\n * @see Fetch API {@link https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API}\n * @see AbortController {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortController}\n */\nexport class ConcurrentFetcher {\n    //private commonErrors = {\n    //  invalidOperation: 'Invalid operation',\n    //  unAuthorized: 'You are not authorized to use this function',\n    //};\n    /**\n     * @param {array} requests - An array of:\n     * - URL: the URL (or resource) for the fetch request. This can be any one of:\n     *   - a string containing the URL\n     *   - an object, such an instance of URL, which has a stringifier that produces a string containing the URL\n     *   - a Request instance\n     * - (optional) fetch options: an object containing options to configure the request.\n     * - (optional) callback object: callback for the response handling:\n     *   - uniqueId: Either the supplied Request Id or the generated Id.\n     *   - data: result from the request. Is null when an error is raised.\n     *   - error: If not null, then an error have occurred for that request\n     *   - abortManager: Only to be used when aborting all subsequent fetch processing: abortManager.abortAll();\n     * - (optional) Request Id: Must identify each request uniquely. Required for error handling and for the caller or callback to navigate.\n     *   - Generated if not given. Known as uniqueId throughout the solution.\n     * - (optional) maxRetries: failed requests will retry up to maxRetries times with a retryDelay between each retry. Defaults to 0 (zero) meaning no retries.\n     * - (optional) statusCodesToRetry: The HTTP response status codes that will automatically be retried.\n     *   - Defaults to: [[100, 199], [429, 429], [500, 599]]\n     * - (optional) retryDelay: delay in ms between each retry. Defaults to 1000 = 1 second.\n     * - (optional) abortTimeout: automatically abort the request after this specified time (in ms).\n     * - (optional) forceReader: Reads response.body instead of either text, json or blob data. Defaults to false. See also cutoffAmount.\n     * - (optional) cutoffAmount: when response content is bigger than cutoffAmount (in KB!) - then response.body will be read in chunks. AND The result will be a blob object (even when reading text and json!). Defaults to 0 (zero) - meaning: no special treatment.\n     *   - blob data will be read in chunks if either forceReader (is true) or cutoffAmount (is reached).\n     *   - text/json data will be read in chunks if forceReader (is true) and returned as a string.\n     *   - text/json data will be read in chunks if cutoffAmount (is reached) and returned as blob data.\n     */\n    constructor(requests) {\n        if (!Array.isArray(requests)) {\n            throw this.CommonError('InvalidArgument', 'requests');\n        }\n        const reqLen = requests.length;\n        if (reqLen < 1) {\n            throw this.CommonError('ArgumentEmpty', 'requests');\n        }\n        const reqArray = [];\n        for (let i = 0; i < reqLen; i++) {\n            reqArray.push(i);\n        }\n        for (let i = 0; i < reqLen; i++) {\n            if (requests[i].requestId) {\n                if (reqArray.includes(requests[i].requestId)) {\n                    throw this.CommonError('DuplicateKey', 'requestId = ' + requests[i].requestId);\n                }\n                else {\n                    reqArray.push(requests[i].requestId);\n                }\n            }\n        }\n        this.requests = requests;\n        this.errors = [];\n        this.abortManager = new AbortManager();\n    }\n    /**\n     * Helper method to introduce a delay (in milliseconds)\n     */\n    delay(ms) {\n        return new Promise((resolve) => setTimeout(resolve, ms));\n    }\n    /**\n     * Retry logic for each individual fetch request\n     */\n    async fetchWithRetry(url, fetchWithSignal, uniqueId, maxRetries, statusCodesToRetry, retryDelay, forceReader, cutoffAmount, progressCallback, countRetries = 0) {\n        let responseStatus = 200;\n        try {\n            const _url = typeof Request !== 'undefined' && url instanceof Request\n                ? url.clone()\n                : url;\n            const response = await fetch(_url, fetchWithSignal);\n            ////console.log(\"response.statusText =\", response.statusText);\n            ////console.log(\"response.userFinalURL =\", response.useFinalURL);\n            responseStatus = response.status;\n            if (!response.ok) {\n                throw new FetchError('Fetch HTTP error! status: ' + response.status, url, response.status);\n            }\n            let contentType = '';\n            let contentLength = 0;\n            if (response.headers) {\n                response.headers.forEach((value, key) => {\n                    //console.log(\"response.header =\", `${key} ==> ${value}`);\n                    if (key.toLowerCase() == 'content-type') {\n                        contentType = value.toLowerCase();\n                    }\n                    else if (key.toLowerCase() == 'content-length') {\n                        contentLength = parseInt(value);\n                    }\n                });\n            }\n            let forceResponseReader = false;\n            if (forceReader && !response.bodyUsed && response.body) {\n                forceResponseReader = true;\n            }\n            let returnData;\n            if (contentType.match(/application\\/[^+]*[+]?(json);?.*/i)) {\n                if (forceResponseReader) {\n                    if (cutoffAmount > 0 &&\n                        contentLength > cutoffAmount * 1024 &&\n                        !response.bodyUsed &&\n                        response.body) {\n                        returnData = await this.fetchBlobStream(response, uniqueId, contentType, contentLength, progressCallback);\n                        //const resp = await this.fetchBlobStream(response, uniqueId, contentType, contentLength, progressCallback);\n                        //data = await resp.blob();\n                    }\n                    else {\n                        returnData = await this.fetchTextStream(response, 'json', uniqueId, contentType, contentLength, progressCallback);\n                    }\n                }\n                else {\n                    returnData = await response.json();\n                }\n            }\n            else if (contentType.includes('text/')) {\n                if (forceResponseReader) {\n                    if (cutoffAmount > 0 &&\n                        contentLength > cutoffAmount * 1024 &&\n                        !response.bodyUsed &&\n                        response.body) {\n                        returnData = await this.fetchBlobStream(response, uniqueId, contentType, contentLength, progressCallback);\n                        //const resp = await this.fetchBlobStream(response, uniqueId, contentType, contentLength, progressCallback);\n                        //data = await resp.blob();\n                    }\n                    else {\n                        returnData = await this.fetchTextStream(response, 'text', uniqueId, contentType, contentLength, progressCallback);\n                    }\n                }\n                else {\n                    returnData = await response.text();\n                }\n            }\n            else {\n                // blob!\n                if (forceResponseReader ||\n                    (cutoffAmount > 0 &&\n                        contentLength > cutoffAmount * 1024 &&\n                        !response.bodyUsed &&\n                        response.body)) {\n                    returnData = await this.fetchBlobStream(response, uniqueId, contentType, contentLength, progressCallback);\n                    //const resp = await this.fetchBlobStream(response, uniqueId, contentType, contentLength, progressCallback);\n                    //data = await resp.blob();\n                }\n                else {\n                    returnData = await response.blob();\n                }\n            }\n            return returnData;\n            //throw new FetchError('Should never happen', url, 0);\n        }\n        catch (err) {\n            if (this.shouldRetryRequest(responseStatus, maxRetries, statusCodesToRetry, countRetries)) {\n                countRetries++;\n                // Wait before retrying\n                await this.delay(retryDelay);\n                // Retry request.\n                return this.fetchWithRetry(url, fetchWithSignal, uniqueId, maxRetries, statusCodesToRetry, retryDelay, forceReader, cutoffAmount, progressCallback, countRetries);\n            }\n            else {\n                // Can't do more...\n                throw err;\n            }\n        }\n    }\n    /**\n     * This is the core method that performs concurrent fetching.\n     * @param {callback} progressCallback - (optional):\n     * - progressCallback?:\n     *   - uniqueId: string\n     *   - completedRequestCount: number\n     *   - totalRequestCount: number\n     * @returns {Promise<ConcurrentFetchResponse>} - A Promise of an array of ConcurrentFetchResponse: results and errors:\n     * - ConcurrentFetchResponse[]:\n     *  - results: any[];\n     *  - errors: { uniqueId: string; url: string | Request; error: Error }[];\n     */\n    async concurrentFetch({ progressCallback, } = {}) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const results = [];\n        let completedCount = 0;\n        const fetchPromises = this.requests.map((request, index) => {\n            const { url, fetchOptions = {}, callback = null, requestId = null, maxRetries = 0, statusCodesToRetry = [[100 - 199], [429 - 429], [500 - 599]], retryDelay = 1000, abortTimeout = 0, forceReader = false, cutoffAmount = 0, } = request;\n            const uniqueId = requestId !== null && requestId !== void 0 ? requestId : index.toString();\n            const abortSignal = abortTimeout > 0\n                ? AbortSignal.any([\n                    this.abortManager.createSignal(uniqueId),\n                    AbortSignal.timeout(abortTimeout),\n                ])\n                : this.abortManager.createSignal(uniqueId);\n            // Default options (can be overridden)\n            // including Representation header: Content-Type\n            const defaultOptions = {\n                method: 'GET',\n                headers: {\n                    Accept: 'application/json',\n                    'Content-Type': 'application/json; charset: UTF-8',\n                },\n                signal: abortSignal,\n            };\n            const fetchWithSignal = { ...defaultOptions, ...fetchOptions }; // signal: abortSignal\n            // Must remove 'Content-Type': 'multipart/form-data', since server expects:\n            // Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryyEmKNDsBKjB7QEqu\n            return this.fetchWithRetry(url, fetchWithSignal, uniqueId, maxRetries, statusCodesToRetry, retryDelay, forceReader, cutoffAmount, progressCallback)\n                .then((data) => {\n                if (callback) {\n                    callback(uniqueId, data, null, this.abortManager);\n                }\n                else {\n                    results[index] = data;\n                }\n            })\n                .catch((err) => {\n                if (err instanceof SyntaxError ||\n                    (err.name && err.name === 'SyntaxError')) {\n                    err = new JsonParseError(err.message, url);\n                    //} else if ((err instanceof TypeError) || (err.name && err.name === \"TypeError\")) {\n                    //  err = new FetchError('Fetch Network error! error: '+err.message, url, 500);\n                }\n                if (callback) {\n                    callback(uniqueId, null, err, this.abortManager);\n                }\n                else {\n                    this.errors.push({ uniqueId, url, error: err });\n                    results[index] = null;\n                }\n            })\n                .finally(() => {\n                completedCount++;\n                if (progressCallback) {\n                    progressCallback(uniqueId, completedCount, this.requests.length, 0, 0);\n                }\n            });\n        });\n        try {\n            await Promise.all(fetchPromises);\n            const filteredResults = results\n                ? results.filter((result) => result !== null)\n                : [];\n            return { results: filteredResults, errors: this.errors };\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (err) {\n            this.errors.push({ uniqueId: 'unknown', url: 'unknown', error: err });\n            this.requests.forEach((request) => {\n                var _a, _b;\n                return (_a = request.callback) === null || _a === void 0 ? void 0 : _a.call(request, (_b = request.requestId) !== null && _b !== void 0 ? _b : 'unknown', null, err, this.abortManager);\n            });\n            return { results: [], errors: this.errors };\n        }\n    }\n    /**\n     *  Reads text-/json-data in chunks.\n     *\n     */\n    async fetchTextStream(fetchResponse, fetchType, uniqueId, contentType, contentLength, progressCallback) {\n        if (!fetchResponse.body) {\n            throw new Error('Response body is empty.');\n        }\n        const reader = fetchResponse.body.getReader();\n        let done, value;\n        let textChunks = '';\n        const decoder = new TextDecoder('utf-8');\n        while (({ done, value } = await reader.read()), !done) {\n            textChunks += decoder.decode(value, { stream: true });\n            if (progressCallback) {\n                progressCallback(uniqueId, 0, 0, textChunks.length, contentLength);\n            }\n        }\n        // empty buffer...\n        textChunks += decoder.decode();\n        if (progressCallback) {\n            progressCallback(uniqueId, 0, 0, textChunks.length, contentLength);\n        }\n        if (fetchType == 'json') {\n            try {\n                return JSON.parse(textChunks);\n            }\n            catch (err) {\n                // If not JsonParseError re-throw, otherwise return textChunks...\n                if (!(err instanceof SyntaxError)) {\n                    throw err;\n                }\n            }\n        }\n        return textChunks;\n    }\n    /**\n     *  Reads blob-data in chunks.\n     *\n     */\n    async fetchBlobStream(fetchResponse, uniqueId, contentType, contentLength, progressCallback) {\n        if (!fetchResponse.body) {\n            throw new Error('Response body is empty.');\n        }\n        //console.log(\"fetchBlobStream =\", `${contentType} ==> ${contentLength}`);\n        const reader = fetchResponse.body.getReader();\n        const chunks = [];\n        let receivedLength = 0;\n        try {\n            //const allChunks = new Uint8Array(contentLength);\n            //let receivedLength = 0;\n            //while (true) {\n            //    const { done, value } = await reader.read();\n            //    if (done) { break; }\n            //    allChunks.set(value, receivedLength);\n            //    receivedLength += value.length;\n            //    if (progressCallback) { progressCallback(uniqueId, 0, 0, receivedLength, contentLength); }\n            //}\n            while (true) {\n                const { done, value } = await reader.read();\n                if (done) {\n                    break;\n                }\n                chunks.push(value);\n                receivedLength += value.length;\n                if (progressCallback) {\n                    progressCallback(uniqueId, 0, 0, receivedLength, contentLength);\n                }\n            }\n            const allChunks = new Uint8Array(receivedLength);\n            let position = 0;\n            for (const chunk of chunks) {\n                allChunks.set(chunk, position);\n                position += chunk.length;\n            }\n            //console.log(Date.now() + \" - blob is streamed: \" + receivedLength + \"/\" + contentLength);\n            return new Blob([allChunks]);\n            //return new Response(allChunks, {\n            //   status: fetchResponse.status,\n            //   statusText: fetchResponse.statusText,\n            //   headers: fetchResponse.headers\n            //});\n            //} catch(err) {\n            //    throw err;\n        }\n        finally {\n            reader.releaseLock();\n        }\n    }\n    /**\n     *  Check whether or not a retry-condition is met.\n     *  Based on the response.status and the statusCodesToRetry configured.\n     *\n     */\n    shouldRetryRequest(responseStatus, maxRetries, statusCodesToRetry, countRetries) {\n        if (maxRetries - countRetries < 1) {\n            return false;\n        }\n        let isInRange = false;\n        for (const [min, max] of statusCodesToRetry) {\n            if (responseStatus >= min && responseStatus <= max) {\n                isInRange = true;\n                break;\n            }\n        }\n        return isInRange;\n    }\n    /**\n     * Calls AbortManager.abort()\n     * see {@link AbortManager}\n     *\n     */\n    abort(uniqueId) {\n        this.abortManager.abort(uniqueId);\n    }\n    /**\n     * Calls AbortManager.abortAll()\n     * see {@link AbortManager}\n     */\n    abortAll() {\n        this.abortManager.abortAll();\n    }\n    /**\n     * Returns a new Error with a common error message.\n     */\n    CommonError(errorType, message) {\n        let errorMessage = '';\n        switch (errorType) {\n            case 'ArgumentEmpty':\n                errorMessage = 'Argument empty: ' + message;\n                break;\n            case 'ArgumentMissing':\n                errorMessage = 'Argument missing: ' + message;\n                break;\n            case 'InvalidArgument':\n                errorMessage = 'Argument is invalid: ' + message;\n                break;\n            case 'DuplicateKey':\n                errorMessage = 'Duplicate key: ' + message;\n                break;\n            case 'ValueError':\n                errorMessage = 'Value error: ' + message;\n                break;\n            default:\n                errorMessage = message;\n        }\n        const error = new Error(errorMessage);\n        error.name = errorType;\n        return error;\n    }\n}\n"],"names":[],"mappings":"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"}